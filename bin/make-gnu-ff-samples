#!/usr/bin/env raku

use PDF::Lite;
use PDF::Content::Page :PageSizes, :&to-landscape;
use PDF::Font::Loader :load-font;
use QueryOS;

# local modules
use GNU::FreeFont-OTF::Subs;
use GNU::FreeFont-OTF::Vars;
use GNU::FreeFont-OTF::FontPaths;

my $os = OS.new;

my $debug = 0;
my $print = 0;
my $help  = 0;
my $ofil  = "GNU-FreeFont-OTF-samples.pdf";
my $ofile = $ofil; # default

if not @*ARGS.elems {
    my $p = $*PROGRAM.basename;

    print qq:to/HERE/;
    Usage: $p <mode> [options]

    Modes
      print   - Creates a local PDF of the text samples for
                the default font ('Free Serif')
    Options
      font=X  - Where X is the desired font reference
      ofile=X - Where X is the desired output PDF file name
      size=X  - Where X is the desired font size (default: 12)
      lang=X  - Where X is the desired language (in place of all languages)
      help    - Show more detailed program information
      A4      - Use A4 paper instead of the default US Letter

    See more information about pangrams and a large list of them
    for many languages at 'https:://clagnut.com'.
    HERE
    exit;
}

# defauults:
my $page-size = "Letter"; # the default
my $font-ref  = "Free Serif";
my $font-size = 12;
my $kerning   = True;
my $lang      = "";

for @*ARGS {
    when /^:i p / {
        ++$print;
    }
    when /^:i ofile '=' (\S+) / {
        # ensure the path ends with ".pdf"
        my $f = ~$0;
        unless $f ~~ /'.pdf' $/ {
            $f ~~ s:g/:i '.' .* $/'.pdf/;
        }
        $ofile = $f;
    }
    when /^:i size '=' (\d+ ['.' \d+]?) $/ {
        $font-size = +$0;
    }
    when /^:i font '=' (\S+) / {
        $font-ref = ~$0;
    }
    when /^:i lang '=' (\S\S) / {
        $lang = ~$0.lc;
        unless %default-samples{$lang}:exists {
            say "FATAL: Language code '$lang' is not recognized.";
            exit;
        }
    }
    when /^:i h / {
        ++$help;
    }
    when /^:i '!'k / {
        $kerning = False;
    }
    when /^:i k / {
        $kerning = True;
    }
    when /^:i a4 / {
        $page-size = "A4";
    }
    when /^:i l / {
        $page-size = "Letter";
    }
    when /^:i d / {
        ++$debug
    }
    default {
        say "FATAL: Unknown argument '$_'";
        say "       Exiting...";
        exit;
    }
}

if $help {
    help();
    exit;
}

=begin comment
sub do-pdf-language-samples(
    $font-ref,
    Str:D :$ofile!,
    :$font-size = 12,
    :$page-size = 'Letter',
    :$kerning   = True,
    :$lang      = False,
    :$debug,
    --> IO::Path
    ) is export {
=end comment

# call the governing sub
my $opath = do-pdf-language-samples $font-ref, :$ofile, :$font-size,
                :$page-size, :$kerning, :$lang, :$debug;
say "See output: $opath";

=finish

my $ff = GNU::FreeFont-OTF.new;
my $font       = $ff.get-font: "Free Serif";
my $title-font = $ff.gett-font: "Free Serif Bold";

$pdf.media-box = %(PageSizes.enums){$media};

$page = $pdf.add-page;
make-page :$pdf, :$page, :$font, :$title-font, :$media, :%h, :landscape(True), :font-name($default-font-stem);

} # end of pages loop

# end the document
$pdf.save-as: $ofil;
#my $landscape = False;
say "See output file: $ofil";

#old code?

#====================================
# subroutines
sub make-page(
              PDF::Lite :$pdf!,
              PDF::Lite::Page :$page!,
              :$font!,
              :$font-size = 10,
              :$title-font!,
              :$media!,
              :$landscape = False,
              :$font-name!,
              :%h!, # data
) is export {
    my ($cx, $cy);

    =begin comment
    my $up = $font.underlne-position;
    my $ut = $font.underlne-thickness;
    note "Underline position:  $up";
    note "Underline thickness: $ut";
    =end comment

    # portrait
    # use the page media-box
    $page.media-box = %(PageSizes.enums){$media};
    $cx = 0.5 * ($page.media-box[2] - $page.media-box[0]);
    $cy = 0.5 * ($page.media-box[3] - $page.media-box[1]);

    if not $landscape {
        die "FATAL: Tom, fix this";
        return
    }

    my (@bbox, @position);
    $page.graphics: {
        .Save;
        .transform: :translate($page.media-box[2], $page.media-box[1]);
        .transform: :rotate(90 * pi/180); # left (ccw) 90 degrees

        # is this right? yes, the media-box values haven't changed,
        # just its orientation with the transformations
        my $w = $page.media-box[3] - $page.media-box[1];
        my $h = $page.media-box[2] - $page.media-box[0];
        $cx = $w * 0.5;

        # get the font's values from FontFactory
        my ($leading, $height, $dh);
        $leading = $height = $dh = $sm.height; #1.3 * $font-size;

        # use 1-inch margins left and right, 1/2-in top and bottom
        # left
        my $Lx = 0 + 72;
        my $x = $Lx;
        # top baseline
        my $Ty = $h - 36 - $dh; # should be adjusted for leading for the font/size
        my $y = $Ty;

        # start at the top left and work down by leading
        #@position = [$lx, $by];
        #my @bbox = .print: "Fourth page (with transformation and rotation)", :@position, :$font,
        #              :align<center>, :valign<center>;

        # print a page title
        my $ptitle = "FontFactory Language Samples for Font: $font-name";
        @position = [$cx, $y];
        @bbox = .print: $ptitle, :@position,
                       :font($title-font), :font-size(16), :align<center>, :kern;
my $pn = "Page $curr-page of $npages"; # upper-right, right-justified
        @position = [$rx, $y];
        @bbox = .print: $pn, :@position,
                       :font($pn-font), :font-size(10), :align<right>, :kern;

        if 1 {
            note "DEBUG: \@bbox with :align\<center>: {@bbox.raku}";
        }

        =begin comment
        # TODO file bug report: @bbox does NOT recognize results of
        #   :align (and probably :valign)
        # y positions are correct, must adjust x left by 1/2 width
        .MoveTo(@bbox[0], @bbox[1]);
        .LineTo(@bbox[2], @bbox[1]);
        =end comment
        my $bwidth = @bbox[2] - @bbox[0];
        my $bxL = @bbox[0] - 0.5 * $bwidth;
        my $bxR = $bxL + $bwidth;

        =begin comment
        # wait until underline can be centered easily

        # underline the title
        # underline thickness, from docfont
        my $ut = $sm.underline-thickness; # 0.703125;
        # underline position, from docfont
        my $up = $sm.underline-position; # -0.664064;
        .Save;
        .SetStrokeGray(0);
        .SetLineWidth($ut);
        # y positions are correct, must adjust x left by 1/2 width
        .MoveTo($bxL, $y + $up);
        .LineTo($bxR, $y + $up);
        .CloseStroke;
        .Restore;
        =end comment

        # show the text font value
        $y -= 2* $dh;

        $y -= 2* $dh;

        for %h.keys.sort -> $k {
            my $country-code = $k.uc;
            my $lang = %h{$k}<lang>;
            my $text = %h{$k}<text>;

            =begin comment
            @position = [$x, $y];
            my $words = qq:to/HERE/;
            -------------------------
              Country code: {$k.uc}
                  Language: $lang
                  Text:     $text
            -------------------------
            =end comment

            # print the dashed in one piece
            my $dline = "-------------------------";
            @bbox = .print: $dline, :position[$x, $y], :$font, :$font-size,
                            :align<left>, :kern; #, default: :valign<bottom>;

            # use the @bbox for vertical adjustment [1, 3];
            $y -= @bbox[3] - @bbox[1];

            #  Country code / Language: {$k.uc} / German
            @bbox = .print: "{$k.uc} - Language: $lang", :position[$x, $y],
                    :$font, :$font-size, :align<left>, :!kern;

            # use the @bbox for vertical adjustment [1, 3];
            $y -= @bbox[3] - @bbox[1];

            # print the line data in two pieces
            #     Text:     $text
            @bbox = .print: "Text: $text", :position[$x, $y],
                    :$font, :$font-size, :align<left>, :kern;

            # use the @bbox for vertical adjustment [1, 3];
            $y -= @bbox[3] - @bbox[1];
        }
        # add a closing dashed line
        # print the dashed in one piece
        my $dline = "-------------------------";
        @bbox = .print: $dline, :position[$x, $y], :$font, :$font-size,
                :align<left>, :kern; #, default: :valign<bottom>;

        #=== end of all data to be printed on this page
        .Restore; # end of all data to be printed on this page
    }
}
